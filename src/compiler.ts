import { mkdtemp, writeFile, readFile, rm } from 'fs/promises';
import { tmpdir } from 'os';
import { promisify } from 'util';
import { execFile as _execFile } from 'child_process';
import { join, resolve, dirname } from 'path'; 
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const execFile = promisify(_execFile);

const isProd = process.env.NODE_ENV === 'production';

export async function compileAs(code: string, transformPath: string) {
  let tmp;

  tmp = await mkdtemp(join(tmpdir(), 'as-'));


  const srcPath = join(tmp, 'module.ts');
  const outPath = join(tmp, 'module.wasm');
  const jsGluePath = join(tmp, 'module.js');


  await writeFile(srcPath, code, 'utf8');

  const ascBin = join(process.cwd(), 'node_modules', '.bin', 'asc');

  const args = [
    "module.ts",
    "--outFile", "module.wasm",
    "-O3",
    "--runtime", "stub",
    "--bindings", "esm",      
    "--transform", transformPath,
  ];
  console.log(args)

  if (!isProd) {
    args.push("--textFile", "module.wat");
  }
  try {
    // Run the compiler
    await execFile(ascBin, args, { cwd: tmp, env: process.env });
    
    // Read the binary AND the generated JS glue
    const wasmBuf = await readFile(outPath);
    const jsGlue = await readFile(jsGluePath, 'utf8');

    await rm(tmp, { recursive: true, force: true });


    return {
      wasm: new Uint8Array(wasmBuf),
      glue: jsGlue // This is the 'Static Binding' code generated by AssemblyScript
    };
  } catch (err: any) {
    const msg = err.stderr ? String(err.stderr) : err.message;
    await rm(tmp, { recursive: true, force: true });
    throw new Error(`AssemblyScript compilation failed: ${msg}`);
  }
}