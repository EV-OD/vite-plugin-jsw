import { mkdtemp, writeFile, readFile, rm } from 'fs/promises';
import { tmpdir } from 'os';
import { join } from 'path';
import { promisify } from 'util';
import { execFile as _execFile } from 'child_process';

const execFile = promisify(_execFile);

const isProd = process.env.NODE_ENV === 'production';

export async function compileAs(code: string) {
  let tmp;
  // if (isProd){
  // tmp = await mkdtemp(join(tmpdir(), 'as-'));
  // }else{
  //   // create actual dir for testing
  //   tmp = join(process.cwd(), 'tmp');
  // }
  tmp = await mkdtemp(join(tmpdir(), 'as-'));

  const srcPath = join(tmp, 'module.ts');
  const outPath = join(tmp, 'module.wasm');
  const jsGluePath = join(tmp, 'module.js');

  await writeFile(srcPath, code, 'utf8');

  const ascBin = join(process.cwd(), 'node_modules', '.bin', 'asc');

  const args = [
    "module.ts",
    "--outFile", "module.wasm",
    "-O3",
    "--runtime", "incremental",
    "--bindings", "esm",      
    "--exportRuntime",        
    "--noAssert",
    "--target", "release",
    "--initialMemory", "64", 
    "--enable", "simd"  ,
    "--memoryGrowth",
    // "--importMemory"  
  ];

  if (!isProd) {
    args.push("--textFile", "module.wat");
  }
  try {
    // Run the compiler
    await execFile(ascBin, args, { cwd: tmp, env: process.env });
    
    // Read the binary AND the generated JS glue
    const wasmBuf = await readFile(outPath);
    const jsGlue = await readFile(jsGluePath, 'utf8');

    // if (isProd){
    await rm(tmp, { recursive: true, force: true });
    // }else{
    //   // in dev mode, keep tmp files for inspection
    // }

    return {
      wasm: new Uint8Array(wasmBuf),
      glue: jsGlue // This is the 'Static Binding' code generated by AssemblyScript
    };
  } catch (err: any) {
    const msg = err.stderr ? String(err.stderr) : err.message;
    await rm(tmp, { recursive: true, force: true });
    throw new Error(`AssemblyScript compilation failed: ${msg}`);
  }
}